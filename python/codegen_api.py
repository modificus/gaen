#!/usr/bin/env python

#-------------------------------------------------------------------------------
# codegen_api.py - Update system_api_meta.cpp with definitions from system_api.h
#
# Gaen Concurrency Engine - http://gaen.org
# Copyright (c) 2014 Lachlan Orr
#
# This software is provided 'as-is', without any express or implied
# warranty. In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
#   1. The origin of this software must not be misrepresented; you must not
#   claim that you wrote the original software. If you use this software
#   in a product, an acknowledgment in the product documentation would be
#   appreciated but is not required.
#
#   2. Altered source versions must be plainly marked as such, and must not be
#   misrepresented as being the original software.
#
#   3. This notice may not be removed or altered from any source
#   distribution.
#-------------------------------------------------------------------------------

import os
import posixpath
import re

META_TEMPLATE = '''\
//------------------------------------------------------------------------------'
// system_api_meta.cpp - Autogenerated with codegen.py from system_api.h
//
// Gaen Concurrency Engine - http://gaen.org
// Copyright (c) 2014 Lachlan Orr
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//   1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
//
//   2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
//
//   3. This notice may not be removed or altered from any source
//   distribution.
//------------------------------------------------------------------------------
#include "engine/stdafx.h"

#include "compose/system_api_meta.h"

namespace gaen
{

ApiSignature gApiSignatures[] = {
                                    <<api_sigs>>

                                    { 0 }
                                };

} // namespace gaen
'''

def gaen_dir():
    scriptdir = os.path.split(os.path.abspath(__file__))[0].replace('\\', '/')
    return posixpath.split(scriptdir)[0]

def system_api_h_path():
    return posixpath.join(gaen_dir(), "src/engine/system_api.h")

def system_api_meta_cpp_path():
    return posixpath.join(gaen_dir(), "src/compose/system_api_meta.cpp")


def codegen_cpp_cpp_path():
    return posixpath.join(gaen_dir(), "src/compose/codegen_cpp.cpp")

def get_codegen_cpp_lines():
    return [line.rstrip() for line in open(codegen_cpp_cpp_path())]

def read_types():
    '''
    Read types from codegen_cpp.cpp so we don't have to maintain
    a separate list here.'
    '''
    lines = get_codegen_cpp_lines()
    cpp_types = []
    compose_types = []
    i = 0
    in_cpp_type_str_func = False
    while i < len(lines):
        line = lines[i]
        if not in_cpp_type_str_func:
            if line == "static const char * cpp_type_str(DataType dt)":
                in_cpp_type_str_func = True
        else:
            if "default:" in line:
                if len(cpp_types) == 0 or len(cpp_types) != len(compose_types):
                    raise Exception('Failed to parse types from codegen_cpp.cpp')
                return cpp_types, compose_types
            m = re.search("case kDT_([^\s]+):", line)
            if m:
                compose_types.append(m.group(1))
            else:
                m = re.search(r'return [^:]+: "([^"]+)";', line)
                if m:
                    cpp_types.append(m.group(1))
        i += 1
    raise Exception('Expected to find "default:" case but did not')

CPP_TYPES, COMPOSE_TYPES = read_types()
CPP_TO_COMPOSE_TYPE = dict(zip(CPP_TYPES, COMPOSE_TYPES))
COMPOSE_TO_CPP_TYPE = dict(zip(COMPOSE_TYPES, CPP_TYPES))

def get_api_lines():
    return [line.rstrip() for line in open(system_api_h_path())]

def type_regex():
    return '(' + '|'.join(CPP_TYPES) + ')'

def api_start_regex():
    return r'^[\s]*' + type_regex() + r'[\s]+([a-zA-Z0-9_]+)\(.*$'

def append_if_api(line, api_strs):
    if line.endswith("const Entity & caller);"):
        api_strs.append(line)
    elif line != 'ApiResult get_last_result();':
        print "Apparent API not being passed a 'const Entity & caller' as last parameter: " + line

def get_api_strs(lines):
    in_call = False
    api_strs = []
    curr_line = ''
    i = 0
    while i < len(lines):
        line = lines[i]
        if in_call:
            line = ' ' + line.strip()
            curr_line += line
            if line.endswith(');'):
                append_if_api(curr_line, api_strs)
                in_call = False
        else: # not in_call
            if re.match(api_start_regex(), line):
                line = line.strip()
                if line.endswith(');'):
                    append_if_api(line, api_strs)
                    curr_line = ''
                else:
                    in_call = True
                    curr_line = line
        i += 1
    return api_strs

def parse_param(param_str):
    items = param_str.split('&')
    if len(items) != 2:
        raise Exception("Param not passed by reference: " + param_str)
    items = items[0].split() + items[1].split()
    const = ''
    if items[0] == 'const' or items[1] == 'const':
        const = 'const '
        items.remove('const')
    if len(items) != 2:
        raise Exception("Param contains too many tokens: " + param_str)
    cpp_type, name = items
    if cpp_type not in CPP_TYPES:
        raise Exception("Invalid param type: " + param_str)
    return (const + cpp_type + '&', const + CPP_TO_COMPOSE_TYPE[cpp_type], name)
            

def parse_api_str(api_str):
    m = re.match(type_regex() + r'[\s]+([^\s]+)[\s]*\(([^\)]*)\);', api_str)
    if not m:
        raise Exception("api_str does not match expeced regex: " + api_str)
    else:
        rettype = (m.group(1), CPP_TO_COMPOSE_TYPE[m.group(1)])
        name = m.group(2)
        params = [p.strip() for p in m.group(3).split(',')]
        if len(params) < 1 or "Entity &" not in params[-1]:
            raise Exception("last parameter of api must be of type Entity &: " + api_str)
        params = params[:-1] # remove the last 'Entity &' parameter
        params = [parse_param(p) for p in params]
        return name, rettype, params
    
def api_type_decl(parsed_param):
    if parsed_param.startswith('const '):
        return "CONST_DT(kDT_%s)" % parsed_param.split(' ')[1]
    else:
        return "kDT_" + parsed_param

def api_decl(parsed_api):
    return "{ HASH::%s, %s, { %s } }" % (parsed_api[0],
                                         api_type_decl(parsed_api[1][1]),
                                         ', '.join([api_type_decl(p[1]) for p in parsed_api[2]]))

def build_metadata():
    lines = get_api_lines()
    api_strs = get_api_strs(lines)
    api_decls = [api_decl(parse_api_str(api_str)) for api_str in api_strs]
    indent = ' ' * 36
    return META_TEMPLATE.replace("<<api_sigs>>", (',\n' + indent).join(api_decls) + ',')

def read_file(filename):
    f = open(filename, 'r')
    d = f.read()
    f.close()
    return d

def write_metadata():
    new_data = build_metadata()
    old_data = read_file(system_api_meta_cpp_path())
    if new_data != old_data:
        print "Writing " + system_api_meta_cpp_path()
        with open(system_api_meta_cpp_path(), 'wb') as f:
            f.write(new_data)

if __name__=='__main__':
    write_metadata()

