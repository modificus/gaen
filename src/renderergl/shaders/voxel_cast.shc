//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
const uint kImageCount = 16; // max is 16 since 4 bits in VoxelRef for imageIdx
const uint kImageSize = 8192;
const uint kPixelSize = 8; // RG32U
const uint kPixelsPerVoxel = 8; // 8 VoxelRefs per voxel, 8 bytes each, pixels are 8
const uint kVoxelRefsPerPixel = 1; // 1 VoxelRef per RG32U pixel (8 bytes each)
const uint kMaxVoxelIndex = 8388608; // 2 ** 23, we have 23 bits for index, which fits perfectly into 8192x8192x8byte image

// Sub voxels
const uint kLeftBottomBack   = 0;  // 000
const uint kLeftBottomFront  = 1;  // 001
const uint kLeftTopBack      = 2;  // 010
const uint kLeftTopFront     = 3;  // 011
const uint kRightBottomBack  = 4;  // 100
const uint kRightBottomFront = 5;  // 101
const uint kRightTopBack     = 6;  // 110
const uint kRightTopFront    = 7;  // 111


// Voxel faces
const uint kFaceNone   = 0;
const uint kFaceLeft   = 1;
const uint kFaceRight  = 2;
const uint kFaceBottom = 3;
const uint kFaceTop    = 4;
const uint kFaceBack   = 5;
const uint kFaceFront  = 6;


// Voxel types
const uint kTerminalEmpty = 0;
const uint kTerminalFull  = 1;
const uint kNonTerminal   = 2;

//------------------------------------------------------------------------------
// Constants (END)
//------------------------------------------------------------------------------



//------------------------------------------------------------------------------
// Structs
//------------------------------------------------------------------------------
struct VoxelRef
{
    uint type; // see Voxel types consts
    uint material;
    uint filledNeighbors;
    uint imageIdx;
    uint voxelIdx;
};


struct VoxelRoot
{
    mat3 rot;
    vec3 pos;
    VoxelRef children;
    float rad;
};

struct AABB_MinMax
{
    vec3 min; // min coord values along each axis
    vec3 max; // max coord values along each axis
};

//------------------------------------------------------------------------------
// Structs (END)
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Static Data Structures
//------------------------------------------------------------------------------

// Normals from faces in local coords
const vec3 kNormals[7] = { vec3( 0.0,  0.0,  0.0),
                           vec3(-1.0,  0.0,  0.0),   // left
                           vec3( 1.0,  0.0,  0.0),   // right
                           vec3( 0.0, -1.0,  0.0),   // bottom
                           vec3( 0.0,  1.0,  0.0),   // top
                           vec3( 0.0,  0.0, -1.0),   // back
                           vec3( 0.0,  0.0,  1.0) }; // front

//------------------------------------------------------------------------------

// Based upon which voxel was hit, the order in which we should
// search children for a hit.
const uint kVoxelSearchOrder[6][4][8] =
{
    { // left
        { // LeftBottomBack
            kLeftBottomBack,
            kLeftBottomFront,
            kLeftTopBack,
            kLeftTopFront,

            kRightBottomBack,
            kRightBottomFront,
            kRightTopBack,
            kRightTopFront
        },

        { // LeftBottomFront
            kLeftBottomFront,
            kLeftTopFront,
            kLeftBottomBack,
            kLeftTopBack,

            kRightBottomFront,
            kRightTopFront,
            kRightBottomBack,
            kRightTopBack
        },

        { // LeftTopFront
            kLeftTopFront,
            kLeftTopBack,
            kLeftBottomFront,
            kLeftBottomBack,

            kRightTopFront,
            kRightTopBack,
            kRightBottomFront,
            kRightBottomBack
        },

        { // LeftTopBack
            kLeftTopBack,
            kLeftBottomBack,
            kLeftTopFront,
            kLeftBottomFront,

            kRightTopBack,
            kRightBottomBack,
            kRightTopFront,
            kRightBottomFront
        }
    },

    { // right
        { // RightBottomFront
            kRightBottomFront,
            kRightBottomBack,
            kRightTopFront,
            kRightTopBack,

            kLeftBottomFront,
            kLeftBottomBack,
            kLeftTopFront,
            kLeftTopBack
        },

        { // RightBottomBack
            kRightBottomBack,
            kRightTopBack,
            kRightBottomFront,
            kRightTopFront,

            kLeftBottomBack,
            kLeftTopBack,
            kLeftBottomFront,
            kLeftTopFront
        },

        { // RightTopBack
            kRightTopBack,
            kRightTopFront,
            kRightBottomBack,
            kRightBottomFront,

            kLeftTopBack,
            kLeftTopFront,
            kLeftBottomBack,
            kLeftBottomFront
        },

        { // RightTopFront
            kRightTopFront,
            kRightBottomFront,
            kRightTopBack,
            kRightBottomBack,

            kLeftTopFront,
            kLeftBottomFront,
            kLeftTopBack,
            kLeftBottomBack
        }
    },

    { // bottom
        { // LeftBottomBack
            kLeftBottomBack,
            kRightBottomBack,
            kLeftBottomFront,
            kRightBottomFront,

            kLeftTopBack,
            kRightTopBack,
            kLeftTopFront,
            kRightTopFront
        },

        { // RightBottomBack
            kRightBottomBack,
            kRightBottomFront,
            kLeftBottomBack,
            kLeftBottomFront,

            kRightTopBack,
            kRightTopFront,
            kLeftTopBack,
            kLeftTopFront
        },

        { // RightBottomFront
            kRightBottomFront,
            kLeftBottomFront,
            kRightBottomBack,
            kLeftBottomBack,

            kRightTopFront,
            kLeftTopFront,
            kRightTopBack,
            kLeftTopBack
        },

        { // LeftBottomFront
            kLeftBottomFront,
            kLeftBottomBack,
            kRightBottomFront,
            kRightBottomBack,

            kLeftTopFront,
            kLeftTopBack,
            kRightTopFront,
            kRightTopBack
        }
    },

    { // top
        { // LeftTopFront
            kLeftTopFront,
            kRightTopFront,
            kLeftTopBack,
            kRightTopBack,

            kLeftBottomFront,
            kRightBottomFront,
            kLeftBottomBack,
            kRightBottomBack
        },

        { // RightTopFront
            kRightTopFront,
            kRightTopBack,
            kLeftTopFront,
            kLeftTopBack,

            kRightBottomFront,
            kRightBottomBack,
            kLeftBottomFront,
            kLeftBottomBack
        },

        { // RightTopBack
            kRightTopBack,
            kLeftTopBack,
            kRightTopFront,
            kLeftTopFront,

            kRightBottomBack,
            kLeftBottomBack,
            kRightBottomFront,
            kLeftBottomFront
        },

        { // LeftTopBack
            kLeftTopBack,
            kLeftTopFront,
            kRightTopBack,
            kRightTopFront,

            kLeftBottomBack,
            kLeftBottomFront,
            kRightBottomBack,
            kRightBottomFront
        }
    },

    { // back
        { // RightBottomBack
            kRightBottomBack,
            kLeftBottomBack,
            kRightTopBack,
            kLeftTopBack,

            kRightBottomFront,
            kLeftBottomFront,
            kRightTopFront,
            kLeftTopFront
        },

        { // LeftBottomBack
            kLeftBottomBack,
            kLeftTopBack,
            kRightBottomBack,
            kRightTopBack,

            kLeftBottomFront,
            kLeftTopFront,
            kRightBottomFront,
            kRightTopFront
        },

        { // LeftTopBack
            kLeftTopBack,
            kRightTopBack,
            kLeftBottomBack,
            kRightBottomBack,

            kLeftTopFront,
            kRightTopFront,
            kLeftBottomFront,
            kRightBottomFront
        },

        { // RightTopBack
            kRightTopBack,
            kRightBottomBack,
            kLeftTopBack,
            kLeftBottomBack,

            kRightTopFront,
            kRightBottomFront,
            kLeftTopFront,
            kLeftBottomFront
        }
    },

    { // front
        { // LeftBottomFront
            kLeftBottomFront,
            kRightBottomFront,
            kLeftTopFront,
            kRightTopFront,

            kLeftBottomBack,
            kRightBottomBack,
            kLeftTopBack,
            kRightTopBack
        },

        { // RightBottomFront
            kRightBottomFront,
            kRightTopFront,
            kLeftBottomFront,
            kLeftTopFront,

            kRightBottomBack,
            kRightTopBack,
            kLeftBottomBack,
            kLeftTopBack
        },

        { // RightTopFront
            kRightTopFront,
            kLeftTopFront,
            kRightBottomFront,
            kLeftBottomFront,

            kRightTopBack,
            kLeftTopBack,
            kRightBottomBack,
            kLeftBottomBack
        },

        { // LeftTopFront
            kLeftTopFront,
            kLeftBottomFront,
            kRightTopFront,
            kRightBottomFront,

            kLeftTopBack,
            kLeftBottomBack,
            kRightTopBack,
            kRightBottomBack
        }
    }
};

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Static Data Structures (END)
//------------------------------------------------------------------------------



//------------------------------------------------------------------------------
// Globals
//------------------------------------------------------------------------------
layout (local_size_x = 16, local_size_y = 16) in;

// un_FrameBuffer output
layout (location=0, rgba8, binding=0) uniform image2D un_FrameBuffer;

// Voxel roots
layout (location=1, rg32ui, binding=1) uniform uimageBuffer un_VoxelRoots;

// Voxel world data
layout (location=2, rg32ui, binding=2) uniform uimageBuffer un_VoxelData;

layout (location=3) uniform uint un_VoxelRootCount;
layout (location=4) uniform vec4 un_CameraDir;
layout (location=5) uniform vec3 un_CameraPos;
layout (location=6) uniform mat4 un_CameraProjectionInv;

//------------------------------------------------------------------------------
// Globals (END)
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Functions
//------------------------------------------------------------------------------
vec4 uint_to_color(uint u)
{
    return vec4(float((u & 0xff000000) >> 24) / 255.0,
                float((u & 0x00ff0000) >> 16) / 255.0,
                float((u & 0x0000ff00) >>  8) / 255.0,
                float(u & 0x000000ff) / 255.0);
}

//------------------------------------------------------------------------------

AABB_MinMax aabb_from_rad(float rad)
{
    return AABB_MinMax(vec3(-rad), vec3(rad));
}

//------------------------------------------------------------------------------

bool test_ray_box(out uint faceHit,
                  out float entryDist,
                  out float exitDist,
                  vec3 rayPos,
                  vec3 invRayDir,
                  AABB_MinMax aabb)
{
    // On GPU, intersect box looks something like:
    // See http://prideout.net/blog/?p=64
    /*
      bool IntersectBox(Ray r, AABB aabb, out float t0, out float t1)
      {
      vec3 invR = 1.0 / r.Dir;
      vec3 tbot = invR * (aabb.Min-r.Origin);
      vec3 ttop = invR * (aabb.Max-r.Origin);
      vec3 tmin = min(ttop, tbot);
      vec3 tmax = max(ttop, tbot);
      vec2 t = max(tmin.xx, tmin.yz);
      t0 = max(t.x, t.y);
      t = min(tmax.xx, tmax.yz);
      t1 = min(t.x, t.y);
      return t0 <= t1;
      }
    */


    vec3 tbot = invRayDir * (aabb.min - rayPos);
    vec3 ttop = invRayDir * (aabb.max - rayPos);
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 t = max(tmin.xx, tmin.yz);
    float t0 = max(t.x, t.y);
    t = min(tmax.xx, tmax.yz);
    float t1 = min(t.x, t.y);


    // find the face that was hit, only one condition is true,
    // and this eliminates branching.
    // If none are true, we have no collision.

    faceHit = 0;
    bool isHit = t0 <= t1;

    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.x) && t0 == tbot.x) * 1);
    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.x) && t0 == ttop.x) * 2);
    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.y) && t0 == tbot.y) * 3);
    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.y) && t0 == ttop.y) * 4);
    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.z) && t0 == tbot.z) * 5);
    faceHit = max(faceHit, uint(isHit && !isinf(invRayDir.z) && t0 == ttop.z) * 6);

    faceHit = faceHit;
    entryDist = t0;
    exitDist = t1;

    return faceHit != kFaceNone;
}

//------------------------------------------------------------------------------

VoxelRef unpack_voxel_ref(uvec2 pix)
{
    VoxelRef ref;

    ref.type = pix.r & 0x3; // 2 bits
    ref.material = (pix.r & 0xffc) >> 2; // 10 bits
    
    ref.imageIdx = (pix.r & 0x7000) >> 12; // 3 bits
    ref.voxelIdx = ((pix.g & 0x3f) << 17) | ((pix.r & 0xffff8000) >> 15); // 23 bits (17 in .r, 6 in .g)

    ref.filledNeighbors = (pix.g & 0xffffffc0) >> 6; // 26 bits

    return ref;
}

//------------------------------------------------------------------------------

VoxelRoot extract_voxel_root(uint voxelRoot)
{
    int pixStart = int(voxelRoot * kPixelsPerVoxel);

    uvec4 pix0 = imageLoad(un_VoxelRoots, pixStart);
    uvec4 pix1 = imageLoad(un_VoxelRoots, pixStart + 1);
    uvec4 pix2 = imageLoad(un_VoxelRoots, pixStart + 2);
    uvec4 pix3 = imageLoad(un_VoxelRoots, pixStart + 3);
    uvec4 pix4 = imageLoad(un_VoxelRoots, pixStart + 4);
    uvec4 pix5 = imageLoad(un_VoxelRoots, pixStart + 5);
    uvec4 pix6 = imageLoad(un_VoxelRoots, pixStart + 6);
    uvec4 pix7 = imageLoad(un_VoxelRoots, pixStart + 7);

    VoxelRoot root;

    root.pos = vec3(uintBitsToFloat(pix0.r),
                    uintBitsToFloat(pix0.g),
                    uintBitsToFloat(pix1.r));

    root.rot = mat3(uintBitsToFloat(pix1.g),
                    uintBitsToFloat(pix2.r),
                    uintBitsToFloat(pix2.g),

                    uintBitsToFloat(pix3.r),
                    uintBitsToFloat(pix3.g),
                    uintBitsToFloat(pix4.r),

                    uintBitsToFloat(pix4.g),
                    uintBitsToFloat(pix5.r),
                    uintBitsToFloat(pix5.g));

    root.rad = uintBitsToFloat(pix6.r);
    // pix6.g is padding in C struct

    root.children = unpack_voxel_ref(uvec2(pix7));

    return root;
}

vec3 quat_multiply(vec4 qlhs, vec3 vrhs)
{
    float x2 = qlhs.x * 2.0;
    float y2 = qlhs.y * 2.0;
    float z2 = qlhs.z * 2.0;
    float xx2 = qlhs.x * x2;
    float yy2 = qlhs.y * y2;
    float zz2 = qlhs.z * z2;
    float xy2 = qlhs.x * y2;
    float xz2 = qlhs.x * z2;
    float yz2 = qlhs.y * z2;
    float wx2 = qlhs.w * x2;
    float wy2 = qlhs.w * y2;
    float wz2 = qlhs.w * z2;

    vec3 vres;
    vres.x = (1.0 - (yy2 + zz2)) * vrhs.x + (xy2 - wz2) * vrhs.y + (xz2 + wy2) * vrhs.z;
    vres.y = (xy2 + wz2) * vrhs.x + (1.0 - (xx2 + zz2)) * vrhs.y + (yz2 - wx2) * vrhs.z;
    vres.z = (xz2 - wy2) * vrhs.x + (yz2 + wx2) * vrhs.y + (1.0 - (xx2 + yy2)) * vrhs.z;
    return vres;
}

//------------------------------------------------------------------------------
// Functions (END)
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Main Program
//------------------------------------------------------------------------------
void main(void)
{
    // Prepare our ray for this pixel
    vec2 windowSize = vec2(float(gl_WorkGroupSize.x * gl_NumWorkGroups.x),
                           float(gl_WorkGroupSize.y * gl_NumWorkGroups.y));

    vec3 rayScreenPos = vec3(2.0 * float(gl_GlobalInvocationID.x) / windowSize.x - 1.0,
                             2.0 * float(gl_GlobalInvocationID.y) / windowSize.y - 1.0,
                             0.0);

    vec3 rayDirProj = normalize(un_CameraProjectionInv * vec4(rayScreenPos, 1.0)).xyz;

    vec3 rayDir = quat_multiply(un_CameraDir, rayDirProj);
    vec3 invRayDir = 1.0 / rayDir;
    vec3 rayPos = un_CameraPos;

    vec3 rayDirCol = (rayScreenPos + vec3(1.0, 1.0, 1.0)) / vec3(2.0, 2.0, 2.0);


    VoxelRoot root = extract_voxel_root(0);

    // LORRTEMP: Keep below to prevent copmiler from stripping un_VoxelData if it isn't being used
    ivec2 coord = ivec2(gl_WorkGroupSize.x * gl_NumWorkGroups.x,
                        gl_WorkGroupSize.y * gl_NumWorkGroups.y);
    uvec4 voxel = imageLoad(un_VoxelData, int(gl_GlobalInvocationID.y * coord.x + gl_GlobalInvocationID.x));
    // LORRTEMP (END)


    AABB_MinMax rootAabb = aabb_from_rad(root.rad);

    uint faceHit;
    float entryDist;
    float exitDist;

    bool hit = test_ray_box(faceHit, entryDist, exitDist, rayPos, invRayDir, rootAabb);

    imageStore(un_FrameBuffer,
               ivec2(gl_GlobalInvocationID.xy),
               vec4(abs(kNormals[faceHit]), 1.0));
}
//------------------------------------------------------------------------------
// Main Program (END)
//------------------------------------------------------------------------------
