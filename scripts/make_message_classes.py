#!/usr/bin/env python

#-------------------------------------------------------------------------------
# field_meta.py - Convert field meta definitions in c++ code
#
# Gaen Concurrency Engine - http://gaen.org
# Copyright (c) 2014 Lachlan Orr
#
# This software is provided 'as-is', without any express or implied
# warranty. In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
#   1. The origin of this software must not be misrepresented; you must not
#   claim that you wrote the original software. If you use this software
#   in a product, an acknowledgment in the product documentation would be
#   appreciated but is not required.
#
#   2. Altered source versions must be plainly marked as such, and must not be
#   misrepresented as being the original software.
#
#   3. This notice may not be removed or altered from any source
#   distribution.
#-------------------------------------------------------------------------------

'''
Convert field meta definitions into C++ classes.
'''

import os
import posixpath
import inspect

MESSAGE_CLASS_TEMPLATE = '''\
//------------------------------------------------------------------------------
// <<message_name>>Message.h - Autogenerated message class for <<message_name>>
//
// Gaen Concurrency Engine - http://gaen.org
// Copyright (c) 2014 Lachlan Orr
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//   1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
//
//   2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
//
//   3. This notice may not be removed or altered from any source
//   distribution.
//------------------------------------------------------------------------------

#ifndef GAEN_ENGINE_MESSAGES_<<message_name_caps>>MESSAGE_H
#define GAEN_ENGINE_MESSAGES_<<message_name_caps>>MESSAGE_H

<<includes>>
namespace gaen
{

class <<message_name>>MessageReader
{
public:
    <<message_name>>MessageReader(const MessageQueue::MessageAccessor & msgAcc)
      : mMsgAcc(msgAcc)
    {
<<reader_data_member_init>>
    }

<<reader_getters>>
        
private:
    const MessageQueue::MessageAccessor & mMsgAcc;

<<reader_data_members>>    
};



class <<message_name>>MessageWriter : protected MessageWriter
{
public:
    <<message_name>>MessageWriter(fnv msgId,
    <<message_name_indent>>              u32 flags,
    <<message_name_indent>>              task_id source,
    <<message_name_indent>>              task_id target<<payload_decl>>)
      : MessageWriter(msgId,
                      flags,
                      source,
                      target,
                      to_cell(<<payload_value>>),
                      <<block_count>>) {}
    
<<writer_setters>>
};

} // namespace gaen

#endif // #ifndef GAEN_ENGINE_MESSAGES_<<message_name_caps>>MESSAGE_H
'''




MESSAGES_CMAKE_TEMPLATE = '''\
#-------------------------------------------------------------------------------
# messages.cmake - Autogenerated file containing the list of message .h files
#
# Gaen Concurrency Engine - http://gaen.org
# Copyright (c) 2014 Lachlan Orr
#
# This software is provided 'as-is', without any express or implied
# warranty. In no event will the authors be held liable for any damages
# arising from the use of this software.
#
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
#
#   1. The origin of this software must not be misrepresented; you must not
#   claim that you wrote the original software. If you use this software
#   in a product, an acknowledgment in the product documentation would be
#   appreciated but is not required.
#
#   2. Altered source versions must be plainly marked as such, and must not be
#   misrepresented as being the original software.
#
#   3. This notice may not be removed or altered from any source
#   distribution.
#-------------------------------------------------------------------------------

SET (engine_message_defs_SOURCES
<<message_header_files>>
)  
'''




class GenericField(object):
    def __init__(self, *args, **kwargs):
        for k, v in kwargs.iteritems():
            if type(v) == list: # append to list
                if hasattr(self, k):
                    l = getattr(self, k)
                    l += v
            else: # all other values just set as attributes
                setattr(self, k, v)

    def __str__(self):
        return self.name + ' : ' + repr(self.__dict__)
            
    payload = False
    includes = ['engine/MessageWriter.h']


# cell fields
class cellField(GenericField):
    cell_count = 1

class i32Field(cellField):
    pass

class u32Field(cellField):
    pass

class f32Field(cellField):
    pass
    
class boolField(cellField):
    pass
    
class colorField(cellField):
    pass
    


# dcell fields
class dcellField(GenericField):
    cell_count = 2

class i64Field(dcellField):
    pass
    
class u64Field(dcellField):
    pass
    
class f64Field(dcellField):
    pass
    
class PointerField(dcellField):
    type_name = 'void *'



# qcell fields
class Vec4Field(GenericField):
    cell_count = 4
    includes = GenericField.includes + ['engine/math.h']



# multi-block fields
class TaskField(GenericField):
    cell_count = 8
    includes = GenericField.includes + ['engine/Task.h']

class Mat34Field(GenericField):
    cell_count = 12
    includes = GenericField.includes + ['engine/math.h']


def print_message(msg):
    s = '%s:\n  %s\n Fields:\n  ' % (msg.object_name, repr(msg.__dict__))
    s += '\n  '.join([str(f) for f in msg.fields])
    print s


def upper_first(s):
    return s[0].upper() + s[1:]

def lower_first(s):
    return s[0].lower() + s[1:]

BLOCK_CELL_COUNT = 4 # cells per block, blocks are 16 bytes
class FieldHandlerType(type):
    '''
    Metaclass to build FieldHandler classes.
    '''
    def __new__(cls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes looking for fields
        has_payload = False
        curr_block = 0
        curr_byte = 0
        fields = []
        includes = []
        newattrs = {'object_name': name,
                    'fields': fields,
                    'includes': includes,
                    'payload_field': None}

        for attrname, attrvalue in attrs.iteritems():
            if isinstance(attrvalue, GenericField):
                fieldname, field = attrname, attrvalue
                field_class_name = field.__class__.__name__
                if not field_class_name.endswith('Field'):
                    raise Exception('Field class must end in "Field"')
                
                field.name = fieldname

                if not hasattr(field, 'type_name'):
                    field.type_name = field_class_name[:-5]
                
                for inc in field.includes:
                    if inc not in includes:
                        includes.append(inc)

                field.block_count = field.cell_count / BLOCK_CELL_COUNT
                
                # handle payload
                if field.payload:
                    if has_payload:
                        raise Exception('Only one payload field permitted')
                    if field.cell_count > 4:
                        raise Exception('Payload must be 4 bytes or less')
                    has_payload = True
                    newattrs['payload_field'] = field
                # handle block sizing
                else:
                    remaining = BLOCK_CELL_COUNT - curr_byte
                    if field.cell_count > remaining and curr_byte > 0:
                        curr_block += 1
                        curr_byte = 0
                    field.block_start = curr_block
                    field.block_cell_start = curr_byte
                    curr_byte += field.cell_count % BLOCK_CELL_COUNT
                    curr_block += field.cell_count / BLOCK_CELL_COUNT

                    if (field.cell_count > BLOCK_CELL_COUNT and field.cell_count % BLOCK_CELL_COUNT != 0):
                        raise Exception("We don't currently support multi block fields that aren't a multiple of 16 bytes")

                    # We'll need some data members for the class for larger than block size
                    # fields.  This is so we can have a place to copy them into if they
                    # happen to wrap the message ring.
                    if (field.block_count > 1):
                        field.member_var  = 'm'  + upper_first(field.name)
                        field.member_pvar = 'mp' + upper_first(field.name)

                fields.append(field)

        newattrs['block_count'] = curr_block + (0 if curr_byte == 0 else 1)
        return super(FieldHandlerType, cls).__new__(cls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(FieldHandlerType, self).__init__(name, bases, attrs)
        
        if len(self.fields) > 0:
            MESSAGES.append(self)


class FieldHandler(object):
    __metaclass__ = FieldHandlerType

def messages_def_path():
    scriptdir = os.path.split(os.path.abspath(__file__))[0].replace('\\', '/')
    gaendir = posixpath.split(scriptdir)[0]
    return posixpath.join(gaendir, 'src/engine/message_defs')

def parse_messages_def():
    context = globals()
    context['MESSAGES'] = []
    path = posixpath.join(messages_def_path(), 'messages.def')
    with open(path) as f:
        exec f in context
    return context['MESSAGES']

def template_subst(template, replacements):
    for k, v in replacements.iteritems():
        template = template.replace('<<%s>>' % k, v)
    return template

UNION_TYPES = {u32Field:  'u',
               i32Field:  'i',
               f32Field:  'f',
               boolField: 'b'}

def union_type(field):
    return UNION_TYPES[type(field)]


def block_accessor(field):
    if field.cell_count == 1:
        return 'c[%d]' % field.block_cell_start
    elif field.cell_count == 2:
        return 'd[%d]' % (field.block_cell_start / 2,)
    elif field.cell_count == 4:
        return 'q'
    else:
        raise Exception('Invalid field size for block accessor')

def gen_includes(includes):
    inc = []
    for i in includes:
        inc.append('#include "%s"\n' % i)
    return ''.join(inc)

def gen_reader_member_init(msg_meta):
    lines = []
    for f in msg_meta.fields:
        if f.block_count > 1:
            lines.append('        if (&msgAcc[%d] > &msgAcc[%d])' % (f.block_start + f.block_count - 1, f.block_start))
            lines.append('        {')
            lines.append('            // field is contiguous in ring buffer')
            lines.append('            %s = reinterpret_cast<const %s*>(&msgAcc[%d]);' % (f.member_pvar, f.type_name, f.block_start))
            lines.append('        }')
            lines.append('        else')
            lines.append('        {')
            lines.append('            // field wraps ring buffer, copy it into our datamember')
            lines.append('            for (u32 i = 0; i < %d; ++i)' % f.block_count)
            lines.append('            {')
            lines.append('                block_at(&%s, i) = msgAcc[i + %d];' % (f.member_var, f.block_start))
            lines.append('            }')
            lines.append('            %s = &%s;' % (f.member_pvar, f.member_var))
            lines.append('        }')
            lines.append('')
            
    return '\n'.join(lines)

def gen_reader_getters(msg_meta):
    lines = []
    for f in msg_meta.fields:
        if f.payload:
            lines.append('    %s %s() const { return mMsgAcc.message().payload.%s; }' % (f.type_name, f.name, union_type(f)))
        elif type(f) == PointerField:
            n = f.name
            if n.startswith('p'):
                n = n[1:]
            lines.append('    %s %s() const { return static_cast<%s>(mMsgAcc[%d].%s.p); }' % (f.type_name, lower_first(n), f.type_name, f.block_start, block_accessor(f)))
        elif f.block_count <= 1:
            lines.append('    %s %s() const { return mMsgAcc[%d].%s.%s; }' % (f.type_name, f.name, f.block_start, block_accessor(f), union_type(f)))
        else:
            lines.append('    const %s & %s() const { return *%s; }' % (f.type_name, f.name, f.member_pvar))
    return '\n'.join(lines)
    
def gen_reader_data_members(msg_meta):
    lines = []
    for f in msg_meta.fields:
        if f.block_count > 1:
            lines.append('    %s %s;' % (f.type_name, f.member_var))
            lines.append('    const %s * %s;' % (f.type_name, f.member_pvar))

    if len(lines) > 0:
        lines.insert(0, '    // These members provide storage for fields larger than a block that wrap the ring buffer')

    return '\n'.join(lines)

def gen_payload_decl(msg_meta):
    for f in msg_meta.fields:
        if f.payload:
            return ',\n%s                  %s %s' % (' ' * len(msg_meta.object_name), f.type_name, f.name)
    return ''

def gen_payload_value(msg_meta):
    for f in msg_meta.fields:
        if f.payload:
            return f.name
    return '0'
    

def gen_writer_setters(msg_meta):
    lines = []
    for f in msg_meta.fields:
        if f.payload:
            lines.append('    void set%s(%s val) { mMsgAcc.message().payload.%s = val; }' % (upper_first(f.name), f.type_name, union_type(f)))
        elif type(f) == PointerField:
            n = f.name
            if n.startswith('p'):
                n = n[1:]
            lines.append('    void set%s(%s pVal) { mMsgAcc[%d].%s.p = pVal; }' % (n, f.type_name, f.block_start, block_accessor(f)))
        elif f.block_count <= 1:
            lines.append('    void set%s(%s val) { mMsgAcc[%d].%s.%s = val; }' % (upper_first(f.name), f.type_name, f.block_start, block_accessor(f), union_type(f)))
        else:
            lines.append('    void set%s(const %s & val)' % (upper_first(f.name), f.type_name))
            lines.append('    {')
            lines.append('        for (u32 i = 0; i < %d; ++i)' % f.block_count)
            lines.append('        {')
            lines.append('            mMsgAcc[i + %d] = block_at(&val, i);' % f.block_start)
            lines.append('        }')
            lines.append('    }')
    return '\n'.join(lines)
    
def gen_message_class(msg_meta):
    repl = {'message_name_caps'      : msg_meta.object_name.upper(),
            'message_name'           : msg_meta.object_name,
            'message_name_indent'    : ' ' * len(msg_meta.object_name),
            'includes'               : gen_includes(msg_meta.includes),
            'reader_data_member_init': gen_reader_member_init(msg_meta),
            'reader_getters'         : gen_reader_getters(msg_meta),
            'reader_data_members'    : gen_reader_data_members(msg_meta),
            'payload_decl'           : gen_payload_decl(msg_meta),
            'payload_value'          : gen_payload_value(msg_meta),
            'block_count'            : str(msg_meta.block_count),
            'writer_setters'         : gen_writer_setters(msg_meta),
    }

    return template_subst(MESSAGE_CLASS_TEMPLATE, repl)

def gen_message_cmake(msg_metas):
    lines = []
    for msg_meta in msg_metas:
        lines.append('  message_defs/%sMessage.h' % msg_meta.object_name)
    lines.sort()
    return MESSAGES_CMAKE_TEMPLATE.replace('<<message_header_files>>', '\n'.join(lines))

def read_file_data(path):
    with open(path, 'rb') as in_f:
        old_data = in_f.read()
        return old_data

def replace_file_if_different(path, data):
    if not os.path.exists(path) or read_file_data(path) != data:
        print 'Writing ' + path
        with open(path, 'wb') as out_f:
            out_f.write(data)

def gen_message_classes():
    msg_metas = parse_messages_def()
    for msg_meta in msg_metas:
        cpp_data = gen_message_class(msg_meta)
        cpp_path = posixpath.join(messages_def_path(), msg_meta.object_name + 'Message.h')
        replace_file_if_different(cpp_path, cpp_data)
    cmake_data = gen_message_cmake(msg_metas)
    cmake_path = posixpath.join(messages_def_path(), 'messages.cmake')
    replace_file_if_different(cmake_path, cmake_data)
        

if __name__ == '__main__':
    gen_message_classes()


